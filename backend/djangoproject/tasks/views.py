import json
from django.conf import settings
from rest_framework import status, views
from rest_framework.response import Response
from drf_spectacular.utils import extend_schema, OpenApiParameter, OpenApiResponse
import redis
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
import logging
import traceback
import sys

from .serializers import (
    GenerateRandomNumberSerializer, 
    ReverseStringSerializer,
    TaskResponseSerializer, 
    TaskResultSerializer
)


# Task registry - maps task_type to serializer class
TASK_SERIALIZERS = {
    'generate_random_number': GenerateRandomNumberSerializer,
    'reverse_string': ReverseStringSerializer,
    # Add more task serializers here as they are created
}

# List of available tasks with descriptions
AVAILABLE_TASKS = {
    'generate_random_number': 'Generate a random number between a min and max value',
    'reverse_string': 'Reverse a given text string',
    # Add more task descriptions here
}


class TaskDispatcherView(views.APIView):
    """
    Generic view to dispatch any supported task type.
    
    This eliminates the need to create a separate view for each task type,
    making the codebase more maintainable and scalable.
    """
    @extend_schema(
        parameters=[
            OpenApiParameter(
                name='task_type',
                location=OpenApiParameter.PATH,
                description='The type of task to dispatch',
                required=True,
                type=str,
                enum=list(AVAILABLE_TASKS.keys())
            )
        ],
        responses={
            202: OpenApiResponse(
                response=TaskResponseSerializer,
                description="Task successfully submitted"
            ),
            400: OpenApiResponse(description="Invalid parameters for task"),
            404: OpenApiResponse(description="Task type not found")
        },
        description="Generic endpoint to dispatch any supported task type",
    )
    def post(self, request, task_type, *args, **kwargs):
        # Validate task type exists
        if task_type not in AVAILABLE_TASKS:
            return Response(
                {"error": f"Unknown task type: {task_type}"}, 
                status=status.HTTP_404_NOT_FOUND
            )
        
        # Get serializer for this task type
        serializer_class = TASK_SERIALIZERS.get(task_type)
        if not serializer_class:
            return Response(
                {"error": f"No serializer configured for task type: {task_type}"}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )
            
        serializer = serializer_class(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        # Create task message
        task_data = {
            "user_id": request.user.id,
            "task_type": task_type,
            "parameters": serializer.validated_data
        }
        
        # Send task to Redis queue
        redis_client = redis.Redis(
            host=settings.REDIS_HOST,
            port=settings.REDIS_PORT,
            decode_responses=True
        )
        
        # Publish to Redis tasks queue
        redis_client.publish(
            settings.REDIS_TASKS_QUEUE,
            json.dumps(task_data)
        )
        
        # Return a response with task info
        return Response({
            'task_id': 'pending',  # Actual task ID will be generated by Celery
            'task_type': task_type,
            'status': 'submitted'
        }, status=status.HTTP_202_ACCEPTED)


class TasksInfoView(views.APIView):
    """
    View to list all available tasks and their descriptions.
    """
    @extend_schema(
        responses={
            200: OpenApiResponse(
                description="List of available tasks"
            )
        },
        description="Get information about available tasks",
    )
    def get(self, request, *args, **kwargs):
        return Response(AVAILABLE_TASKS)


logger = logging.getLogger(__name__)

@csrf_exempt
def test_redis_publish(request):
    """Test endpoint to publish a message directly to Redis"""
    try:
        user_id = request.GET.get('user_id')
        message = request.GET.get('message', 'Test message')
        
        if not user_id:
            return JsonResponse({"error": "user_id parameter required"}, status=400)
        
        # Create a test payload
        payload = {
            "user_id": user_id,
            "task_id": "test-task-id",
            "task_type": "test_message",
            "status": "completed",
            "result": {"message": message}
        }
        
        # Connect to Redis
        redis_client = redis.Redis(
            host=settings.REDIS_HOST,
            port=settings.REDIS_PORT,
            decode_responses=True
        )
        
        # Publish to results queue
        result = redis_client.publish(settings.REDIS_RESULTS_QUEUE, json.dumps(payload))
        
        logger.info(f"Published test message to Redis for user {user_id}, result: {result}")
        
        return JsonResponse({
            "status": "success",
            "message": f"Test message published to Redis for user {user_id}",
            "queue": settings.REDIS_RESULTS_QUEUE,
            "payload": payload,
            "redis_publish_result": result
        })
        
    except Exception as e:
        logger.error(f"Error in test_redis_publish: {str(e)}")
        traceback.print_exc(file=sys.stderr)
        return JsonResponse({"error": str(e)}, status=500)
