import json
from django.conf import settings
from rest_framework import status, views
from rest_framework.response import Response
from drf_spectacular.utils import extend_schema, OpenApiParameter, OpenApiResponse
import redis

from .serializers import (
    GenerateRandomNumberSerializer, 
    ReverseStringSerializer,
    TaskResponseSerializer, 
    TaskResultSerializer
)


# Task registry - maps task_type to serializer class
TASK_SERIALIZERS = {
    'generate_random_number': GenerateRandomNumberSerializer,
    'reverse_string': ReverseStringSerializer,
    # Add more task serializers here as they are created
}

# List of available tasks with descriptions
AVAILABLE_TASKS = {
    'generate_random_number': 'Generate a random number between a min and max value',
    'reverse_string': 'Reverse a given text string',
    # Add more task descriptions here
}


class TaskDispatcherView(views.APIView):
    """
    Generic view to dispatch any supported task type.
    
    This eliminates the need to create a separate view for each task type,
    making the codebase more maintainable and scalable.
    """
    @extend_schema(
        parameters=[
            OpenApiParameter(
                name='task_type',
                location=OpenApiParameter.PATH,
                description='The type of task to dispatch',
                required=True,
                type=str,
                enum=list(AVAILABLE_TASKS.keys())
            )
        ],
        responses={
            202: OpenApiResponse(
                response=TaskResponseSerializer,
                description="Task successfully submitted"
            ),
            400: OpenApiResponse(description="Invalid parameters for task"),
            404: OpenApiResponse(description="Task type not found")
        },
        description="Generic endpoint to dispatch any supported task type",
    )
    def post(self, request, task_type, *args, **kwargs):
        # Validate task type exists
        if task_type not in AVAILABLE_TASKS:
            return Response(
                {"error": f"Unknown task type: {task_type}"}, 
                status=status.HTTP_404_NOT_FOUND
            )
        
        # Get serializer for this task type
        serializer_class = TASK_SERIALIZERS.get(task_type)
        if not serializer_class:
            return Response(
                {"error": f"No serializer configured for task type: {task_type}"}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )
            
        serializer = serializer_class(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        # Create task message
        task_data = {
            "user_id": request.user.id,
            "task_type": task_type,
            "parameters": serializer.validated_data
        }
        
        # Send task to Redis queue
        redis_client = redis.Redis(
            host=settings.REDIS_HOST,
            port=settings.REDIS_PORT,
            decode_responses=True
        )
        
        # Publish to Redis tasks queue
        redis_client.publish(
            settings.REDIS_TASKS_QUEUE,
            json.dumps(task_data)
        )
        
        # Return a response with task info
        return Response({
            'task_id': 'pending',  # Actual task ID will be generated by Celery
            'task_type': task_type,
            'status': 'submitted'
        }, status=status.HTTP_202_ACCEPTED)


class TasksInfoView(views.APIView):
    """
    View to list all available tasks and their descriptions.
    """
    @extend_schema(
        responses={
            200: OpenApiResponse(
                description="List of available tasks"
            )
        },
        description="Get information about available tasks",
    )
    def get(self, request, *args, **kwargs):
        return Response(AVAILABLE_TASKS)
